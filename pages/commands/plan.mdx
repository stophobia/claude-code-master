import { Callout } from 'nextra/components'
import { DownloadMarkdown } from '../../components/DownloadMarkdown'
import { commandContents } from '../../components/commandContents'

# /plan (계획)

<DownloadMarkdown
  filename="plan.md"
  content={commandContents['plan']}
  folderPath="~/.claude/commands/"
/>

요구사항 재진술, 위험 평가, 단계별 구현 계획 생성.

## 설명

```yaml
description: 요구사항 재진술, 위험 평가, 단계별 구현 계획 생성
```

<Callout type="info" emoji="📋">
  코드 작성 전 사용자 확인을 기다립니다. **`planner` 에이전트**를 호출합니다.
</Callout>

## 이 커맨드가 하는 일

1. **요구사항 재진술** - 무엇을 구축해야 하는지 명확히
2. **위험 식별** - 잠재적 문제와 차단 요소 표면화
3. **단계 계획 생성** - 구현을 단계로 분해
4. **확인 대기** - 진행 전 반드시 사용자 승인 받기

## 사용 시점

- 새 기능 시작
- 중요한 아키텍처 변경
- 복잡한 리팩토링 작업
- 여러 파일/컴포넌트에 영향
- 요구사항이 불명확하거나 모호할 때

## 사용 예시

```
사용자: /plan 마켓이 해결될 때 실시간 알림을 추가해야 합니다

에이전트 (planner):
# 구현 계획: 실시간 마켓 해결 알림

## 요구사항 재진술
- 사용자가 지켜보는 마켓이 해결될 때 알림 전송
- 여러 알림 채널 지원 (인앱, 이메일, 웹훅)

## 구현 단계

### 1단계: 데이터베이스 스키마
- 알림 테이블 추가: id, user_id, market_id, type, status
- user_notification_preferences 테이블 추가

### 2단계: 알림 서비스
- lib/notifications.ts에 알림 서비스 생성
- BullMQ/Redis로 알림 큐 구현

### 3단계: 통합 지점
- 마켓 해결 로직에 훅 추가

### 4단계: 프론트엔드 컴포넌트
- NotificationBell 컴포넌트 생성
- 실시간 업데이트 구현

## 위험
- 높음: 이메일 전달 가능성
- 중간: 마켓당 1000+ 사용자 시 성능
- 낮음: 실시간 구독 오버헤드

## 예상 복잡도: 중간

**확인 대기 중**: 이 계획으로 진행할까요?
```

## 응답 방법

계획에 동의하면:
- "예" 또는 "진행"

변경을 원하면:
- "수정: [변경 내용]"
- "다른 접근 방식: [대안]"
- "2단계 건너뛰고 3단계 먼저"

## 다른 커맨드와의 통합

계획 후:
- `/tdd`를 사용하여 테스트 주도 개발로 구현
- `/build-fix`를 사용하여 빌드 오류 발생 시
- `/code-review`를 사용하여 완료된 구현 검토

<Callout type="error" emoji="⚠️">
  **중요**: planner 에이전트는 명시적으로 계획을 확인할 때까지 코드를 작성하지 **않습니다**.
</Callout>
